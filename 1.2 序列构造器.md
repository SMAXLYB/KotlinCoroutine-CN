# 1.2 序列构造器
&emsp;&emsp;在许多其他语言中例如Python、Rust或者JavaScript，你可以在其中找到一些使用了某些协程形式的结构：
 - async函数(也叫async/await)
 - generator函数(生成下一个值的函数)

我们已经在前面看到过async函数在kotlin中的使用，关于它的细节部分将会在*Coroutine builders*一章中作介绍。kotlin提供了sequence而非generator函数来创建一个序列[^1]。

&emsp;&emsp;Kotlin序列的概念类似于集合(如List或Set)，但它是惰性求值的。也就是说，下一个元素总是在需要时按需计算，因此，序列:
- 执行最少数量的必要操作
- 可以是无限的
- 内存效率更高[^2]

由于这些特性，定义一个builder(构建器)是很有意义的，它可以根据需要计算和“生成”下一个元素。我们用sequence函数来定义它。在lambda表达式中，我们可以调用yield函数来生成序列中的下一个元素。
```kotlin
// sequence构造了一个序列
val seq = sequence {
    yield(1) // 生成序列中的下一个元素
    yield(2)
    yield(3)
}

fun main() {
    // 遍历序列中的元素并打印
    for (num in seq) {
        print(num)
    }
}
```
> sequence函数在这里是一个小型DSL，它的参数是一个带接收者的lambda表达式：suspend SequenceScope<T>.() -> Unit。在lambda内部，this的指向是类型为SequenceScope<T>的对象




[^1]: 更好的是kotlin还提供了flow builders，Flow一个和sequence类似，但是更强大:muscle:的概念，我们将会在后面介绍它。
[^2]: :point_right:详情见《Effective Kotlin》中*Prefer Sequence for big collections with more than on processing step*一文。
