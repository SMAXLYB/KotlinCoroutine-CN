# 1.1 为什么需要Kotlin协程？
&emsp;&emsp;为什么我们需要学习Kotlin协程？在如何实现异步操作这个问题上，JVM中早就有像RxJava或者Reactor这样成熟的库。此外，Java本身也有多线程支持。也有许多人选择普通又古老的回调(callback)方式。毫无疑问，我们已经有了很多选择。

&emsp;&emsp;答案是Kotlin协程的功能远不止如此。协程的概念起源于1963年，经过很多年之后才真正有了标准行业实现。协程用一种为了在现实生活中的用例中提供完美的帮助而设计的库，将半个世纪前的论文展示的强大能力连接了起来。另外，Kotlin协程是支持多平台的，这意味着它可以在所有Kotlin平台使用(例如：JVM, JS, IOS等等)。最后，它不需要你大改代码结构，我们可以很轻松的使用Kotlin协程提供的各种功能(这对于RxJava或者回调来说是很难的)，这使得Kotlin协程对新人非常友好。

&emsp;&emsp;让我们在实战中看看吧。我们将探索如何通过协程和其他通用方法去解决不同的常见用例。我分了2个典型的用例：Android和后台业务逻辑实现。

## Android中的协程(或者其他前端应用)
&emsp;&emsp;当你作为前端实现应用逻辑，你经常要做的是：
> 1. 从一个或多个数据源(API，数据库，首选项，另一个应用程序等等)获取一些数据
> 2. 处理这些数据
> 3. 对数据做一些事情(显示在视图中，存储在数据库中，发送给API)

为了使我们的讨论更实际，让我们首先假设我们正在开发一个Android应用程序。我们将从一个问题开始，在这个问题中，我们需要从API获取新闻，对它们进行排序，并在屏幕上显示它们。我们要编写的函数代码可能会这样表示:
```kotlin
fun onCreate() {
    val news = getNewsFromApi()
    val sortedNews = news.sortedByDesending { it.publishedAt }
    view.showNews(sortedNews)
}
```
遗憾的是，仅仅这样这还不够。如果我们在主线程上运行这个函数(主线程是唯一能够更新应用程序视图的线程)，我们会阻塞整个应用程序。这就是为什么在Android上在主线程上做网络操作是非法的，上面的代码会抛出异常。如果我们运行在另一个线程上，我们将不能在视图上显示新闻，因为这只能在主线程上完成。
#### 线程切换
我们可以通过两次切换线程来解决这些问题，如下面的代码所示：
```kotlin
fun onCreate() {
    thread{ //第一次切换
        val news = getNewsFromApi()
    	val sortedNews = news.sortedByDesending { it.publishedAt }
    	runOnUiThread { //第二次切换
            view.showNews(sortedNews)
        }
    }
}
```
这种线程切换的方式在一些应用程序中仍在使用，然而它是有问题的，原因如下：
> - 这里没有取消这些线程的机制，因此我们经常面临着内存泄漏
> - 制造这么多线程的代价是很昂贵的
> - 频繁地切换线程是令人困惑和难以管理的
> - 代码将不必要地变得更大、更复杂

考虑到所有这些问题，我们需要找到一个更好的机制。
#### 回调
这里有一个方式可以提供帮助：回调。当我们使用该方式时，我们需要将一个函数（一旦数据准备好时立即调用）传递给另一个函数。回调函数（这里不是指回调！）开始执行数据获取，其余的事情发生在另一个线程中，一旦获得数据，我们的回调就会被调用。这种方式表示如下:
```kotlin
fun onCreate() {
    getNewsFromApi { news ->
    	val sortedNews = news.sortedByDesending { it.publishedAt }
        view.showNews(sortedNews)
    }
}
```
我们仍然可能面临内存泄漏，因为我们不会取消不需要的线程。但至少回调函数承担了切换线程的责任。回调架构解决了这个简单的问题，但它也有很多缺点。为了探索它们，让我们讨论一个更复杂的情况，我们需要从三个不同的地方获取数据:
```kotlin
fun onCreate() {
    getNewsFromApi { config ->
        getNewsFromApi(config) { news -> 
        	getUserFromApi { user ->
            	view.showNews(user, news)
            }
        }
    }
}
```
这段代码说完美还非常遥远，原因如下：
> - 获取新闻和用户数据的操作可能是并行的，但我们当前的回调架构不支持这一点(用回调很难实现)
> - 回调不支持取消，会导致内存泄漏
> - 越来越多的缩进使得代码难以阅读，带有多个回调函数的代码通常被认为是高度不可读的，这种情况被称为“回调地狱”，特别是在一些老的Node.JS项目中
> - 当我们使用回调时，很难控制之后的流程

以下显示进度条的方式将不起作用:
```kotlin
fun onCreate() {
    showProgressBar()
    showNes()
    hideProgressBar() // 错误
}
```
进度条本应该立即显示，然后在新闻加载之后被隐藏，但实际上在它显示之后立即被隐藏（异步操作）。为了让这段代码正常工作，我们需要将隐藏进度条作为回调：
```kotlin
fun onCreate() {
    showProgressBar()
    showNes{
        hideProgressBar()
    }
}
```
这就是为什么回调对于重要的项目来说并不完美的原因。让我们看看另一种方法:RxJava和响应流。
#### Rxlava和其他响应流
在Java (Android和后端)中流行的另一种方法是使用响应流(或响应式扩展):RxJava或其后继者Reactor。使用这种方法，所有操作都发生在一个可以启动、被处理和观察的数据流中。这种流支持线程切换和并发处理，因此它们经常用于应用程序的并行处理。下面是我们使用RxJava解决问题的方法:
```kotlin
fun onCreate() {
    // disposables在当用户退出界面时需要被调用cancel()取消流
    disposables += getNewsFromApi()
    	.subscribeOn(Schedulers.io())
    	.observerOn(AndroidSchedulers.mainThread())
    	.map { news ->
             news.sortedByDescending { it.publishedAt }
        }
    	.subscribe { sortedNews -> 
             view.showNews(sortedNews)
        }
}
```
这绝对是一个比回调更好的解决方案：没有数据泄漏，支持取消，正确使用线程。唯一的问题是它很复杂，如果你从一开始就将其与“理想的”代码进行比较(如下所示)，你会发现它们完全不一样：
```kotlin
fun onCreate() {
    val news = getNewsFromApi()
    val sortedNews = news.sortedByDescending { it.publishedAt }
    view.showNews(sortedNews)
}
```
所有例如subscribeOn, observeOn, map或subscribe的函数都需要去学习、取消流的方法需要明确被调用。函数返回的对象必须被包装成Observable或者Single：
```kotlin
fun getNewsFromApi(): Single<List<News>>
```
