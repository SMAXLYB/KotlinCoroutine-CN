# 1.1 为什么需要Kotlin协程？
&emsp;&emsp;为什么我们需要学习Kotlin协程？在如何实现异步操作这个问题上，JVM中早就有像RxJava或者Reactor这样成熟的库。此外，Java本身也有多线程支持。也有许多人选择普通又古老的回调(callback)方式。毫无疑问，我们已经有了很多选择。

&emsp;&emsp;答案是Kotlin协程的功能远不止如此。协程的概念起源于1963年，经过很多年之后才真正有了标准行业实现。协程用一种为了在现实生活中的用例中提供完美的帮助而设计的库，将半个世纪前的论文展示的强大能力连接了起来。另外，Kotlin协程是支持多平台的，这意味着它可以在所有Kotlin平台使用(例如：JVM, JS, IOS等等)。最后，它不需要你大改代码结构，我们可以很轻松的使用Kotlin协程提供的各种功能(这对于RxJava或者回调来说是很难的)，这使得Kotlin协程对新人非常友好。

&emsp;&emsp;让我们在实战中看看吧。我们将探索如何通过协程和其他通用方法去解决不同的常见用例。我分了2个典型的用例：Android和后台业务逻辑实现。

## Android中的协程(或者其他前端应用)
&emsp;&emsp;当你作为前端实现应用逻辑，你经常要做的是：
> 1. 从一个或多个数据源(API，数据库，首选项，另一个应用程序等等)获取一些数据
> 2. 处理这些数据
> 3. 对数据做一些事情(显示在视图中，存储在数据库中，发送给API)

为了使我们的讨论更实际，让我们首先假设我们正在开发一个Android应用程序。我们将从一个问题开始，在这个问题中，我们需要从API获取新闻，对它们进行排序，并在屏幕上显示它们。我们要编写的函数代码可能会这样表示:
```kotlin
fun onCreate() {
    val news = getNewsFromApi()
    val sortedNews = news.sortedByDesending { it.publishedAt }
    view.showNews(sortedNews)
}
```
遗憾的是，仅仅这样这还不够。如果我们在主线程上运行这个函数(主线程是唯一能够更新应用程序视图的线程)，我们会阻塞整个应用程序。这就是为什么在Android上在主线程上做网络操作是非法的，上面的代码会抛出异常。如果我们运行在另一个线程上，我们将不能在视图上显示新闻，因为这只能在主线程上完成。
#### 线程切换
我们可以通过两次切换线程来解决这些问题，如下面的代码所示：
```kotlin
fun onCreate() {
    thread{ //第一次切换
        val news = getNewsFromApi()
    	val sortedNews = news.sortedByDesending { it.publishedAt }
    	runOnUiThread { //第二次切换
            view.showNews(sortedNews)
        }
    }
}
```
这种线程切换的方式在一些应用程序中仍在使用，然而它是有问题的，原因如下：
> - 这里没有取消这些线程的机制，因此我们经常面临着内存泄漏
> - 制造这么多线程的代价是很昂贵的
> - 频繁地切换线程是令人困惑和难以管理的
> - 代码将不必要地变得更大、更复杂

考虑到所有这些问题，我们需要找到一个更好的机制。
#### 回调
这里有一个方式可以提供帮助：回调。当我们使用该方式时，我们需要将一个函数（一旦数据准备好时立即调用）传递给另一个函数。回调函数（这里不是指回调！）开始执行数据获取，其余的事情发生在另一个线程中，一旦获得数据，我们的回调就会被调用。这种方式表示如下:
