# 1.4 协程原理
&emsp;&emsp;肯定有一类人不愿意停留在类似“车子是可以用来开的”这种基础的概念上，他们想翻开车盖去看看车子到底是如何工作的。我就是这类人的其中之一，所以我想挖掘清楚协程是如何工作的。如果你也属于这类人，那么你将会享受本章，如果你不是，那么你可跳过这本章。

&emsp;&emsp;本章不会介绍任何你可能会使用的新工具，并且是纯原理解释性的，本章尝试着向你阐述协程是如何工作的，尽量使你达到满意的程度。主要章节分为：
 - 挂起函数类似于状态机，在函数开始处和挂起函数调用之后都会有一个可能的状态。
 - 标识状态的编号和本地数据都保存在continuation(译注：续程体，后文仍按英文翻译)对象中。
 - 一个函数的continuation包装了另一个函数的continuation，总之，所有这些continuation都代表了我们恢复时使用的调用栈。

&emsp;&emsp;如果你对学习一些内在东西（当然了，会有一些简化）非常感兴趣，那么跟着我开始把。

## Continuation-passing风格 ([译注：参考文章，建议看一下，有助于理解](https://zhuanlan.zhihu.com/p/387239708))
&emsp;&emsp;有很多方法可以实现挂起函数，但Kotlin团队选择了Continuation-passing这种方式来实现，这意味着Continuations(我们在前一章解释过)是被作为一个参数在函数间传递，按照惯例，continuation被放在最后参数的位置。
```kotlin
suspend fun getUser(): User?
suspend fun setUser(user: User)
suspend fun checkAvailability(flight: Flight): Boolean

// 编译之后的样子
fun getUser(continuation: Continuation<*>): Any?
fun setUser(user: User, continuation: Continuation<*>): Any
fun checkAvailability(flight: Flight, continuation: Continuation<*>): Any
```
你可能注意到，函数的返回值和原来的声明的不一样了，它从[Unit/Boolean]变成了[Any]，从[User?]变成了[Any?]，为什么会要这样？因为挂起函数可能会被挂起，所以不会返回声明的类型，这种情况下，会返回一个特殊的标记COROUTINE_SUSPENDED，我们稍后将在实战中看到它。现在需要注意的是，getUser可能返回[User?]或者COROUTINE_SUSPENDED（类型是Any），综合起来返回类型必须是[User?]和Any的超类，所以返回类型是[Any?]。也许有一天Kotlin将会推出新的联合类型，然后我们就可以使用类似[User? | COROUTINE_SUSPENDED]的写法。

## 一个非常简单的函数
为了更加深入，让我们从一个非常简单的函数入手，这个函数将在延迟前后打印一些文字。
```kotlin
suspend fun myFunction() {
    println("Before")
    delay(1000) // 挂起
    println("After")
}
```
你已经可以推断出这个函数签名实际上是什么样子的：
```kotlin
fun myFunction(continuation: Continuation<*>): Any
```
