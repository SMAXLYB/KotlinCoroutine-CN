# 1.3 挂起是如何工作的？
&emsp;&emsp;挂起函数是Kotlin协程的标志，挂起能力是最基本的特征，其他概念都建立在它之上，这就是为什么本章的目标是深入理解它的工作原理。挂起一个协程意味着在中途停止它，这类似于停止一个视频游戏——你在一个检查点(checkpoint)保存，关闭游戏，你和你的电脑可以集中精力做其他的事情。然后，过一段时间，你想继续，所以你再次打开游戏，从保存的检查点恢复，这样你就可以从之前离开的地方开始游戏。这是协程的一个类比。它们也可以被停止，当它们停止时，它们会返回一个***Continuation***，这就像游戏中的保存——我们可以使用它从我们停止的地方继续。

## 恢复（resume, 也译作“中断后继续”）
&emsp;&emsp;让我们来探究一下，首先，我们需要一个协程，创建一个挂起的主函数是最简单的方式，这是我们的出发点。
```kotlin
suspend fun main() {
    println("Before")
    
    println("After")
}

// Before
// After
```
这是一个简单的程序，它将打印“Before”和“After”。如果我们在中间挂起那么将会发生什么呢？为了达到挂起的目的，我们可以使用协程标准库提供的suspendCoroutine函数[^1]。
```kotlin
suspend fun main() {
    println("Before")

    suspendCoroutine<Unit> { }

    println("After")
}

// Before
```
如果你调用上面的代码，你看不到“After”，程序也不会停止运行(因为我们的主函数永远不会结束)。协程在"Before"之后被挂起。我们的游戏停止了，永远不会恢复。怎么办:question:之前提到可以让程序恢复的Continuation在哪里？再看一下对suspendCoroutine的调用，注意它以一个lambda表达式({&emsp;&emsp;})结束，作为参数传递进去的函数会在挂起之前被调用，这个函数得到一个continuation作为参数。
```kotlin
suspend fun main() {
    println("Before")

    suspendCoroutine<Unit> { continuation ->
        println("Before too")
    }

    println("After")
}

// Before
// Before too
```
一个函数就地调用另一个函数并不是什么新鲜事，这类似于let、apply或uselines。suspendCoroutine函数也是这样设计的，这使得在挂起之前使用continuation成为可能，在suspendCoroutine之后调用的话就太晚了。因此，作为参数传递给suspendCoroutine函数的lambda表达式会在挂起之前被调用，这个lambda用于存储在哪里继续，或者计划后续是否要恢复。

我们可以使用它立即恢复:
```kotlin
suspend fun main() {
    println("Before")

    suspendCoroutine<Unit> { continuation ->
        continuation.resume(Unit)
    }

    println("After")
}

// Before
// After
```
注意“After”在例子中被打印出来了，因为我们在suspendCoroutine中调用了恢复。
> 从Kotlin 1.3开始，Continuation的定义发生了变化。1.3之前Continuation类中只有resumeWith方法，1.3之后标准库中增加了两个扩展函数resume和resumeWithException，实际上内部也是直接调用resumewith，它们都不需要额外导包。
```kotlin
public inline fun <T> Continuation<T>.resume(value: T): Unit =
    resumeWith(Result.success(value))

public inline fun <T> Continuation<T>.resumeWithException(exception: Throwable): Unit =
    resumeWith(Result.failure(exception))
```
我们也可以用它来启动一个新线程，休眠一段时间后然后恢复:
```kotlin
suspend fun main() {
    println("Before")

    suspendCoroutine<Unit> { continuation ->
        thread {
            Thread.sleep(1000)
            continuation.resume(Unit)
        }
    }

    println("After")
}

// Before
// (1 second delay)
// After
```
这是个重要的发现。注意，启动线程可以被抽取到一个函数里面，恢复操作可以放在回调中，这样continuation就可被lambda捕获，如下面的代码所示：
```kotlin
fun invokeAfterSecond(operation: () -> Unit) {
    thread {
        Thread.sleep(1000)
        operation.invoke()
    }
}

suspend fun main() {
    println("Before")

    suspendCoroutine<Unit> { continuation ->
        invokeAfterSecond {
            continuation.resume(Unit)
        }
    }

    println("After")
}

// Before
// (1 second delay)
// After
```
这种方式是可行的，但是它创建了线程然后停止活动一秒钟后线程就被结束了，这是不必要的，线程可并不便宜(开销大)，为什么要浪费它们呢？一个更好的方式是设置一个闹钟，在jvm上，我们可以使用ScheduledExecutorService，我们可以设置它在一定的时间调用continuation.resume(Unit)。
```kotlin
private val executor = Executors.newSingleThreadScheduledExecutor {
    Thread(it, "scheduler").apply { isDaemon = true }
}

suspend fun main() {
    println("Before")

    suspendCoroutine<Unit> { continuation ->
        executor.schedule({
            continuation.resume(Unit)
        }, 1000, TimeUnit.MILLISECONDS)
    }

    println("After")
}

// Before
// (1 second delay)
// After
```
挂起一定的时间这似乎是个很有用的功能，让我们把它提取到一个函数中，命名为delay。
```kotlin
private val executor = Executors.newSingleThreadScheduledExecutor {
    Thread(it, "scheduler").apply { isDaemon = true }
}

suspend fun delay(time: Long) {
    suspendCoroutine<Unit> { continuation ->
        executor.schedule({
            continuation.resume(Unit)
        }, time, TimeUnit.MILLISECONDS)
    }
}

suspend fun main() {
    println("Before")

    delay(1000)

    println("After")
}

// Before
// (1 second delay)
// After
```
executor仍然使用的是线程，但是它只有一个线程来为所有协程执行delay函数，这比每次我们需要等待一段时间的时候而去阻塞一个线程好多了。这正是Kotlin协程库之前实现delay的方式，现在的实现更加复杂，主要为了支持测试，不过基本思路还是一样的。

#### 带着值恢复
你可能会关心的一件事是，为什么我们要将Unit传递给resume函数。你可能还想知道为什么我使用Unit作为suspendCoroutine的类型参数。事实上这两个参数为同一类型并不是巧合。它也从函数和Continuation参数的泛型类型返回。

[^1]: suspendCoroutine函数内部直接调用了suspendCoroutineUninterceptedOrReturn，这是一个原生函数，具体实现并不可见，因为它是和平台相关的([Intrinsic](https://juejin.cn/post/6863119536200253454))。
