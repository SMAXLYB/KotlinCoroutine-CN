# 1.3 挂起是如何工作的？
&emsp;&emsp;挂起函数是Kotlin协程的标志，挂起能力是最基本的特征，其他概念都建立在它之上，这就是为什么本章的目标是深入理解它的工作原理。挂起一个协程意味着在中途停止它，这类似于停止一个视频游戏——你在一个检查点(checkpoint)保存，关闭游戏，你和你的电脑可以集中精力做其他的事情。然后，过一段时间，你想继续，所以你再次打开游戏，从保存的检查点恢复，这样你就可以从之前离开的地方开始游戏。这是协程的一个类比。它们也可以被停止，当它们停止时，它们会返回一个***Continuation***，这就像游戏中的保存——我们可以使用它从我们停止的地方继续。

## 恢复（resume, 也译作“中断后继续”）
&emsp;&emsp;让我们来探究一下，首先，我们需要一个协程，创建一个挂起的主函数是最简单的方式，这是我们的出发点。
```kotlin
suspend fun main() {
    println("Before")
    
    println("After")
}

// Before
// After
```
这是一个简单的程序，它将打印“Before”和“After”。如果我们在中间挂起那么将会发生什么呢？为了达到挂起的目的，我们可以使用协程标准库提供的suspendCoroutine函数[^1]。
```kotlin
suspend fun main() {
    println("Before")

    suspendCoroutine<Unit> { }

    println("After")
}

// Before
```
如果你调用上面的代码，你看不到“After”，程序也不会停止运行(因为我们的主函数永远不会结束)。协程在"Before"之后被挂起。我们的游戏停止了，永远不会恢复。怎么办:question:之前提到可以让程序恢复的Continuation在哪里？再看一下对suspendCoroutine的调用，注意它以一个lambda表达式({&emsp;&emsp;})结束，作为参数传递进去的函数会在挂起之前被调用，这个函数得到一个continuation作为参数。
```kotlin
suspend fun main() {
    println("Before")

    suspendCoroutine<Unit> { continuation ->
        println("Before too")
    }

    println("After")
}

// Before
// Before too
```
一个函数就地调用另一个函数并不是什么新鲜事，这类似于let、apply或uselines。suspendCoroutine函数也是这样设计的，这使得在挂起之前使用continuation成为可能，在suspendCoroutine之后调用的话就太晚了。因此，作为参数传递给suspendCoroutine函数的lambda表达式会在挂起之前被调用，这个lambda用于存储在哪里继续，或者计划后续是否要恢复。

我们可以使用它立即恢复:
```kotlin
suspend fun main() {
    println("Before")

    suspendCoroutine<Unit> { continuation ->
        continuation.resume(Unit)
    }

    println("After")
}

// Before
// After
```
注意“After”在例子中被打印出来了，因为我们在suspendCoroutine中调用了恢复。
> 从Kotlin 1.3开始，Continuation的定义发生了变化。1.3之前Continuation类中只有resumeWith方法，1.3之后标准库中增加了两个扩展函数resume和resumeWithException，实际上内部也是直接调用resumewith，它们都不需要额外导包。
```kotlin
public inline fun <T> Continuation<T>.resume(value: T): Unit =
    resumeWith(Result.success(value))

public inline fun <T> Continuation<T>.resumeWithException(exception: Throwable): Unit =
    resumeWith(Result.failure(exception))
```


[^1]: suspendCoroutine函数内部直接调用了suspendCoroutineUninterceptedOrReturn，这是一个原生函数，具体实现并不可见，因为它是和平台相关的([Intrinsic](https://juejin.cn/post/6863119536200253454))。
